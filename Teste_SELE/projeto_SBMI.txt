
#include <avr/io.h>
#include <stdlib.h>
#include <avr/interrupt.h>
#include "serial_port.h"
#include <math.h>
#include <string.h>
#include <avr/eeprom.h>

#define F_CPU 16000000UL
#define ZCD PD2
#define botao PD7
#define luz PC5

uint16_t EEMEM seg_l, min_l, hora_l, seg_d, min_d, hora_d, modo, assinatura,
		intensidade;

typedef struct {
	int old_b;
	int RE_b;
} Botao;

typedef struct {
	int seg, min, hora;
	int seg_l, min_l, hora_l;
	int seg_d, min_d, hora_d;
	int intensidade; //definir a intensidade para quando se define o ligar a luz
	int modo; 	//0 sem horario para ligar ou desligar
				//1 com horario de ligar e desligar
				//2 com horario só para ligar
				//3 com horario só para desligar

} Relogio;

volatile Relogio clock;

//inicializa as entradas e saídas
void init_io(void);

//inicializa o Timer 0 que serve para calcular o tempo que controla a luminosidade
void init_timer_T0(void);

//incializa o Timer 1 que serve para contar um segundo para incrementar o relógio do sistema
void init_timer_T1(void);

//faz enable às interrupções
void init_interrupt(void);

//incializa a EEPROM caso o valor da assinatura seja diferente de 12345
int init_eeprom(void);

/*inicializa o relógio pedindo ao utilizador para acertar as horas
 *lê a hora para ligar as luzes guardada na EEPROM
 *lê a hora para desligar as luzes guardada na EEPROM
 *lê o modo em que as luzes estão programadas
 */
void init_relogio(void);

//guarda em memória EEPROM as horas, minutos e segundos às quais o utilizador quer que a luz ligue
//guarda também na EEPROM a intensidade à qual ele quer que a luz ligue
void liga_luz_time(void);

//guarda em memória EEPROM as horas, minutos e segundos às quais o utilizador quer que a luz desligue
void desliga_luz_time(void);

//permite ao utilizador definir o modo em que pretende programar a luz para ligar/desligar
void setclock(void);

//altera a intensidade da luz
void altera_lumen(int percent);

//deteta o flanco positivo da ativação do botão
int rising_edge(Botao *B);

//testa se o valor do relógio do sistema é igual às horas definidas para ligar/desligar a luz
int check_time(void);

/*permite receber comandos a partir do teclado e pela porta série
 *os comandos podem ser 0 | 25 | 50 | 75 | 100 para definir a intensidade da luz
 *ou pode ser "setclock" para definir o modo de programação da luz
 */
int input_keyboard(void);

//testa se o valor inserido para a intensidade da luz por parte do utulizador é válido
//se o valor for diferente de 0 | 25 | 50 | 75 | 100, a função diz que o valor inserido é inválido
int check_intensidade(int int_luz);

/*testa se o valor inserido nas horas, minutos ou segundos é valido
 * o valor das horas só pode ser entre 0 e 23
 * o valor dos minutos e dos segundos só pode ser entre 0 e 59
 */
int check_tempo(int tempo, int type);

int main(void) {

	Botao buton;
	buton.RE_b = 0;
	buton.old_b = 0;

	int state = 0, old_state = 0;
	int state_read = 0;
	char state_int = '1';

	//funções de inicialização
	init_io();
	init_timer_T0();
	init_interrupt();

	//inicia a luz (quando se inicia o programa, a luz começa desligada)
	altera_lumen(0);

	init_USART();
	init_timer_T1();
	init_eeprom();
	init_relogio();

	write_string("\r\n--------------Start!---------------\r\n");

	write_string("Insira o valor da luminosidade\r\n"
			"0 | 25 | 50 | 75 | 100\r\n"
			"Ou pressionar o Botao\r\n"
			"Comando setclock para definir horas de ligar/desligar\n\r");

	while (1) {

		if (rising_edge(&buton)) {
			state_read = 1;
		}

		else if (check_time() >= 0) {
			state = check_time();
			if (state == -1)
				state = old_state;
			state_read = 2;
		}

		else {
			state_read = 0;
		}

		switch (state_read) {

		default:
			write_string("ERRO!\r\n");
			state_read = 0;
			break;

			//utilizar a porta de serie;
		case (0):
			state = input_keyboard();
			if (state == -1) {
				state = old_state;
			}
			break;

			//utilizar o botão
		case (1):
			switch (state) {

			default:
				write_string("\r\nERRO!!\n");
				state = 0;
				break;

			case (0):
				//luz desligada
				if (buton.RE_b) {
					state = 1;
					buton.RE_b = 0;
				}
				break;

			case (1):
				//a 25%
				if (buton.RE_b) {
					state = 2;
					buton.RE_b = 0;
				}
				break;

			case (2):
				//a 50%
				if (buton.RE_b) {
					state = 3;
					buton.RE_b = 0;
				}
				break;

			case (3):
				//a 75%
				if (buton.RE_b) {
					state = 4;
					buton.RE_b = 0;
				}
				break;

			case (4):
				//luz ligada
				if (buton.RE_b) {
					state = 0;
					buton.RE_b = 0;
				}
				break;
			}
			break;

			//horas de ligar/desligar
		case (2):
			break;
		}

		//actualiza saida
		if (state == 0) {
			state_int = '0';
			altera_lumen(0);
		} else if (state == 4) {
			state_int = '4';
			altera_lumen(100);
		} else if (state != old_state) {
			if (state == 1) {
				state_int = '1';
				altera_lumen(25);
			} else if (state == 2) {
				state_int = '2';
				altera_lumen(50);
			} else {
				state_int = '3';
				altera_lumen(75);
			}
		}

		//escrever o estado actual
		if (state != old_state) {
			old_state = state;
			write_string("\r\nState: ");
			print_char(state_int);
			write_string("\r\n");
		}
	}
}

void init_io(void) {

	DDRD &= ~(1 << ZCD); //Definir PD2 como entrada para o ZCD
	PORTD |= (1 << ZCD); //pull up resistor em PD2

	//definir e configurar pino do botão
	DDRD &= ~(1 << botao); //Definir PD7 como entrada
	PORTD |= (1 << botao); //pull up resistor PD7

	//definir PC5 como saida para a luz
	DDRC |= (1 << luz);
	return;
}

void init_timer_T0(void) {

	TCCR0B = 0; //stop T0

	TCCR0A = 2; // CTC Mode

	TCNT0 = 0; //começa a contar do zero

	TCCR0B = 5; //pre divisor de 1024

	OCR0A = 250; //valor da contagem

	TIMSK0 |= (1 << OCIE0A);
	return;
}

void init_timer_T1(void) {

	//este timer conta segundos, escala = 1s

	TCCR1B = 0;		//parar TC1
	TCCR1A = 0;		//modo normal
	TCNT1 = 3036;	//valor para iniciar o timer (65536 - 62500)

	TIMSK1 = 0b001;	//ativar a intrupção por overflow
	sei();
	TCCR1B = 4;		//iniciar o timer 1 com predivisão de 256
}

void init_interrupt(void) {
	//definir interrupções
	sei();
	EIMSK |= (1 << INT0);
	EICRA |= (0b10 << ISC00); //falling edge
	EICRA |= (0b10 << ISC10);

}

int init_eeprom(void) {

	if (eeprom_read_word(&assinatura) != 12345) {
		eeprom_update_word(&seg_l, 0);
		eeprom_update_word(&min_l, 0);
		eeprom_update_word(&hora_l, 0);
		eeprom_update_word(&seg_d, 0);
		eeprom_update_word(&min_d, 0);
		eeprom_update_word(&hora_d, 0);
		eeprom_update_word(&modo, 0);
		eeprom_update_word(&intensidade, 0);
		eeprom_update_word(&assinatura, 12345);
		write_string("EEPROM inicializada! \n\r");
		return 1;
	} else
		return 0;
}

void init_relogio(void) {
	char str[10], *ptr;

	write_string("Acertar relogio\n\r");

	do {
		write_string(" -> Horas: ");
		while (!(read_string(str)))
			;
		clock.hora = strtol(str, &ptr, 10);
	} while (!(check_tempo(clock.hora, 0)));

	do {
		write_string(" -> Minutos: ");
		while (!(read_string(str)))
			;
		clock.min = strtol(str, &ptr, 10);
	} while (!(check_tempo(clock.min, 1)));

	do {
		write_string(" -> Segundos: ");
		while (!(read_string(str)))
			;
		clock.seg = strtol(str, &ptr, 10);
	} while (!(check_tempo(clock.seg, 2)));

	clock.seg_l = eeprom_read_word(&seg_l);
	clock.seg_d = eeprom_read_word(&seg_d);
	clock.min_l = eeprom_read_word(&min_l);
	clock.min_d = eeprom_read_word(&min_d);
	clock.hora_d = eeprom_read_word(&hora_d);
	clock.hora_l = eeprom_read_word(&hora_l);
	clock.modo = eeprom_read_word(&modo);
	clock.intensidade = eeprom_read_word(&intensidade);

	write_string("\n");
	write_string("Horas acertadas!\n\r");

}

void liga_luz_time(void) {
	char str[10], *ptr;

	write_string("Ligar a luz:\n\r");

	do {
		write_string(" -> Hora: ");
		while (!(read_string(str)))
			;
		clock.hora_l = strtol(str, &ptr, 10);
		eeprom_update_word(&hora_l, clock.hora_l);
	} while (!(check_tempo(clock.hora_l, 0)));

	do {
		write_string(" -> Minutos: ");
		while (!(read_string(str)))
			;
		clock.min_l = strtol(str, &ptr, 10);
		eeprom_update_word(&min_l, clock.min_l);
	} while (!(check_tempo(clock.min_l, 1)));

	do {
		write_string(" -> Segundos: ");
		while (!(read_string(str)))
			;
		clock.seg_l = strtol(str, &ptr, 10);
		eeprom_update_word(&seg_l, clock.seg_l);
	} while (!(check_tempo(clock.seg_l, 2)));

	do {
		write_string(" -> Intensidade: ");
		while (!(read_string(str)))
			;
		clock.intensidade = strtol(str, &ptr, 10);

	} while (!check_intensidade(clock.intensidade));

	eeprom_update_word(&intensidade, clock.intensidade);
	write_string("\n\r");
	write_string("Hora de ligar programada com sucesso!\n\r");

	return;
}

void desliga_luz_time(void) {
	char str[10], *ptr;

	write_string("Desligar a luz:\n\r");

	do {
		write_string(" -> Hora: ");
		while (!(read_string(str)))
			;
		clock.hora_d = strtol(str, &ptr, 10);
		eeprom_update_word(&hora_d, clock.hora_d);
	} while (!(check_tempo(clock.hora_d, 0)));

	do {
		write_string(" -> Minutos: ");
		while (!(read_string(str)))
			;
		clock.min_d = strtol(str, &ptr, 10);
		eeprom_update_word(&min_d, clock.min_d);
	} while (!(check_tempo(clock.min_d, 1)));

	do {
		write_string(" -> Segundos: ");
		while (!(read_string(str)))
			;
		clock.seg_d = strtol(str, &ptr, 10);
		eeprom_update_word(&seg_d, clock.seg_d);
	} while (!(check_tempo(clock.seg_d, 2)));

	write_string("\n\r");

	write_string("Hora de desligar programada com sucesso!\n\r");

	return;
}

void setclock(void) {
	char str[10], *ptr;

	write_string("Programar hora de ligar e desligar a luz\n\r");

	write_string("Modo de funcionamento?\n\r"
			"0: sem horario para ligar ou desligar\n\r"
			"1: com horario de ligar e desligar\n\r"
			"2: com horario so para ligar\n\r"
			"3: com horario so para desligar\n\r");

	do {
		write_string(" -> Modo: ");
		while (!read_string(str))
			;
		clock.modo = strtol(str, &ptr, 10);
		if (clock.modo < 0 || clock.modo > 3)
			write_string("Modo invalido!\r\n");
	} while (clock.modo < 0 || clock.modo > 3);

	eeprom_update_word(&modo, clock.modo);
	write_string("\n");

	switch (clock.modo) {
	case (0):
		write_string("Relogio sem programacao para ligar/desligar!\n\r");
		return;
	case (1):
		liga_luz_time();
		desliga_luz_time();
		return;

	case (2):
		liga_luz_time();
		return;

	case (3):
		desliga_luz_time();
		return;
	}
}

void altera_lumen(int percent) {

	if (percent == 0) {
		TCCR0B = 0; //stop T0
		PORTC &= ~(1 << luz);
		EIMSK &= ~(1 << INT0); //desativa interrupçao ZCD
		EIMSK |= (1 << INT1); //ativa interrupção botao

	} else if (percent == 100) {
		TCCR0B = 0; //stop T0
		PORTC |= (1 << luz);
		EIMSK &= ~(1 << INT0); //desativa interrupção ZCD
		EIMSK |= (1 << INT1); //ativa interrupção botao

	} else {
		TCCR0B = 5;
		EIMSK |= (1 << INT0); //ativa interrupção ZCD
		EIMSK |= (1 << INT1); //ativa interrupção botao
		OCR0A = (((100 - 30 * log10(percent)) * 160) / (100));
	}
	return;
}

int rising_edge(Botao* B) {

	if (B->RE_b) {
		return 1;
	}

	else if ((!(PIND & (1 << botao))) > B->old_b) {
		//se for percionado o botao e o estado anterior do boão for 0
		B->old_b = !(PIND & (1 << botao));
		B->RE_b = 1;
		return 1;
	}

	else {
		B->old_b = !(PIND & (1 << botao));
		return 0;
	}
}

int check_time(void) {

	int desl, liga, time;

	desl = clock.hora_d * 60 * 60 + clock.min_d * 60 + clock.seg_d;
	liga = clock.hora_l * 60 * 60 + clock.min_l * 60 + clock.seg_l;

	time = clock.hora * 60 * 60 + clock.min * 60 + clock.seg;

	switch (clock.modo) {

	case (0):
		return -1;
		break;

	case (1):
		if (time >= liga && time <= liga + 1) {
			switch (clock.intensidade) {
			case 25:
				return 1;
			case 50:
				return 2;
			case 75:
				return 3;
			case 100:
				return 4;
			default:
				return 4;
			}
		}

		if (time >= desl && time <= desl + 1) {
			return 0;
		}
		break;

	case (2):
		if (time >= liga && time <= liga + 1) {
			switch (clock.intensidade) {
			case 25:
				return 1;
			case 50:
				return 2;
			case 75:
				return 3;
			case 100:
				return 4;
			default:
				return 4;
			}
		}
		break;

	case (3):
		if (time >= desl && time <= desl + 1) {
			return 0;
		}
		break;
	}
	return -1;
}

int input_keyboard(void) {

	int int_luz = 0;
	static char str[50];
	char *ptr;

	do {
		if (!(read_string(str)))
			return -1;			//ainda não acabou a leitura

		if (!(strcasecmp(str, "setclock\n\r"))) {
			setclock();
			return -1;
		}

		int_luz = strtol(str, &ptr, 10);

		if ((int_luz == 0) && (strcasecmp(str, "0\n\r")))
			int_luz = -1;

	} while (!check_intensidade(int_luz));

	if (int_luz == 0)
		return 0;
	else if (int_luz == 25)
		return 1;
	else if (int_luz == 50)
		return 2;
	else if (int_luz == 75)
		return 3;
	else if (int_luz == 100)
		return 4;

	return -1;
}

int check_intensidade(int int_luz) {

	if (int_luz != 0 && int_luz != 25 && int_luz != 50 && int_luz != 75
			&& int_luz != 100) {
		write_string("Comando inserido invalido!\r\n");
		return 0;
	} else
		return 1;
}

int check_tempo(int tempo, int type) {
	//se type = 0 verifica horas
	//se type = 1 verifica minutos
	//se type = 2 verifica segundos

	switch (type) {

	case (0):
		if (tempo < 0 || tempo > 23) {
			write_string("Horas invalidas.\r\n");
			return 0;
		} else
			return 1;
		break;
	case (1):
		if (tempo < 0 || tempo > 59) {
			write_string("Minutos invalidos.\r\n");
			return 0;
		} else
			return 1;
		break;

	case (2):
		if (tempo < 0 || tempo > 59) {
			write_string("Segundos invalidos.\r\n");
			return 0;
		} else
			return 1;
		break;
	}
	return -1;
}

ISR (INT0_vect) {
	//codigo para quando acontece a interrupcao ZCD

	TCCR0B = 5; //inicia o timer

	PORTC &= ~(1 << luz); //desliga a luz

	return;
}

ISR (TIMER1_OVF_vect) {

	TCNT1 = 3036; 	//renicia o timer

	//actualiza o relogio

	clock.seg++;
	if (clock.seg > 59) {
		clock.seg = 0;
		clock.min++;
		if (clock.min > 59) {
			clock.min = 0;
			clock.hora++;
			if (clock.hora > 23) {
				clock.hora = 0;
			}
		}
	}

}

ISR (TIMER0_COMPA_vect) {
	//codigo para quando passa o tempo do timer 0
	PORTC |= (1 << luz); 	//liga a luz

	TCCR0B = 0; //pára o timer

	return;
}

